```markdown
# Sub-Module: TCC Library (`tcclib.sln`)

## Purpose/Functionality

The TCC Library sub-module integrates the Tiny C Compiler (TCC) into Cheat Engine. This allows users to embed, compile, and execute C code directly within Cheat Engine scripts, primarily through special directives like `{$C}` or `{$CCODE}` in Auto Assembler scripts or potentially via Lua.

This feature enables:
*   **On-the-fly C Compilation:** Writing and executing C code snippets without needing an external C compiler or pre-compiling DLLs for simple tasks.
*   **Performance-critical code:** Implementing parts of a cheat or tool in C for better performance than might be achievable with Lua or assembly alone for certain complex logic.
*   **Access to C Libraries/APIs:** Calling standard C library functions or Windows API functions directly from the compiled C code.
*   **Low-level Operations:** Performing tasks that are more naturally expressed in C.

## Structure

*   **`Cheat Engine/tcclib/` Directory:**
    *   Contains the source code of the Tiny C Compiler itself, including:
        *   `tcc.c`, `tcc.h`: Core TCC compiler logic.
        *   `libtcc.c`, `libtcc.h`: The library interface for TCC, allowing it to be embedded in other applications. This is the primary API used by Cheat Engine.
        *   Architecture-specific files (e.g., `i386-gen.c`, `arm-gen.c`) for code generation on different platforms.
        *   Standard C include files (`include/`) and TCC's own library files (`lib/libtcc1.c`).
*   **`tcclib.sln` (as per README):** The Visual Studio solution file used to compile the wrapper DLLs that Cheat Engine's Pascal code interacts with. These DLLs (e.g., `tcc32-32.dll`, `tcc64-64.dll`, and variants for different ABIs like SysV for Linux) internally link against or include `libtcc`.
*   **`Cheat Engine/tcclib.pas`:** The Pascal unit within the main Cheat Engine application that acts as the bridge to the TCC DLLs.
    *   **DLL Loading:** Dynamically loads the appropriate TCC DLL based on the target architecture and OS.
    *   **`TTCC` class:**
        *   Manages a `TCCState` (the TCC compiler context).
        *   Holds function pointers to the API functions exported by the loaded TCC DLL (which are wrappers around `libtcc.h` functions).
        *   Provides methods like `compileScript`, `compileScripts`, and `compileProject` to take C code (as strings or from files) and compile it.
    *   **Symbol Resolution:** Implements a callback (`symbolLookupFunction`) that TCC uses to resolve external symbols. This callback queries Cheat Engine's main symbol handler (`symhandler.pas`), allowing the compiled C code to call Windows APIs, functions within CE itself, or other functions known to CE.
    *   **Memory Output:** Can compile C code directly into memory regions within the target process or Cheat Engine's own process.
    *   **STABS Debug Info Parsing:** Includes sophisticated logic (`TSourceCodeInfo` class) to parse STABS debugging information generated by TCC when the `-g` option is used. This allows mapping executable addresses back to C source lines and inspecting local variables of the compiled C code.

## Mechanism

1.  **Script Parsing:** A Cheat Engine component (e.g., the Auto Assembler via `autoassembler.pas`) encounters a script block like `{$C ... C code ... }` or `{$CCODE ... C code ... }`.
2.  **Code Extraction:** The C source code is extracted from this block.
3.  **Compilation Request:** The component calls functions in `tcclib.pas` (e.g., `tcc.compileScript(...)`).
4.  **TCC Initialization (via `tcclib.pas` and the TCC DLL):**
    *   A `TCCState` is created using `tcc_new()`.
    *   The compilation environment is configured:
        *   Output type is set to memory (`TCC_OUTPUT_MEMORY`).
        *   Include paths are added (e.g., to CE's own include directory containing common headers).
        *   The error callback is set to log errors to CE's interface.
        *   The symbol lookup callback (`symbolLookupFunction`) is registered.
        *   A binary writer callback (e.g., `TCCMemorystreamWriter`) is set to handle where the compiled machine code is written.
5.  **Compilation:**
    *   `tcc_compile_string()` (or `tcc_add_file` then compile) is called with the C source code.
    *   TCC parses the C code. If it encounters external function calls, it uses the registered `symbolLookupFunction`. This function in `tcclib.pas` resolves the symbol using CE's main symbol handler and provides the address back to TCC.
6.  **Relocation & Output:**
    *   `tcc_relocate()` is called. This finalizes the machine code, applying any necessary relocations. The code is written to the specified memory address (or a CE-managed buffer) via the binary writer callback.
    *   The `TTCCMemorystreamWriter` can also store information about the protection flags (read, write, execute) required for different sections of the compiled code.
7.  **Symbol Retrieval (Optional):**
    *   `tcc_get_symbol()` can be used to get the address of specific functions defined within the compiled C code.
    *   If compiled with `-g`, STABS debug information is generated and can be parsed by `TSourceCodeInfo` in `tcclib.pas` to enable source-level debugging.
8.  **Execution:**
    *   The address of the compiled code (or a specific function within it) can now be called by Cheat Engine (e.g., from an Auto Assembler script or Lua).
9.  **Cleanup:** `tcc_delete()` is called to free the `TCCState`.

## Build Process

*   The TCC library source code (`Cheat Engine/tcclib/`) is compiled into various DLLs (e.g., `tcc32-32.dll`, `tcc64-64.dll`, `tcc64-32-linux.dll`) using Visual Studio, as indicated by `tcclib.sln`. These DLLs likely expose the `libtcc.h` API or a subset of it.
*   The `tcclib.pas` unit is part of the main Cheat Engine Lazarus project and dynamically loads these TCC DLLs at runtime.

## Interface with Main Cheat Engine Application

*   The `tcclib.pas` unit provides the high-level interface for other CE components (like Auto Assembler) to use the TCC functionality.
*   It abstracts the complexities of loading the correct TCC DLL, setting up the compiler state, and handling callbacks.
*   The `{$C}` and `{$CCODE}` directives in scripts are the primary user-facing entry points that trigger this module.

This integration allows for powerful inline C scripting within Cheat Engine, complete with symbol resolution against the target process and CE itself, and even source-level debugging information for the dynamically compiled C code.
```
